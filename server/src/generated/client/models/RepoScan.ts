
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `RepoScan` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model RepoScan
 * 
 */
export type RepoScanModel = runtime.Types.Result.DefaultSelection<Prisma.$RepoScanPayload>

export type AggregateRepoScan = {
  _count: RepoScanCountAggregateOutputType | null
  _avg: RepoScanAvgAggregateOutputType | null
  _sum: RepoScanSumAggregateOutputType | null
  _min: RepoScanMinAggregateOutputType | null
  _max: RepoScanMaxAggregateOutputType | null
}

export type RepoScanAvgAggregateOutputType = {
  score: number | null
}

export type RepoScanSumAggregateOutputType = {
  score: number | null
}

export type RepoScanMinAggregateOutputType = {
  id: string | null
  projectId: string | null
  score: number | null
  timestamp: Date | null
  repoPath: string | null
  categoryScoresJson: string | null
  resultsJson: string | null
  productionReady: boolean | null
  readinessReasonsJson: string | null
}

export type RepoScanMaxAggregateOutputType = {
  id: string | null
  projectId: string | null
  score: number | null
  timestamp: Date | null
  repoPath: string | null
  categoryScoresJson: string | null
  resultsJson: string | null
  productionReady: boolean | null
  readinessReasonsJson: string | null
}

export type RepoScanCountAggregateOutputType = {
  id: number
  projectId: number
  score: number
  timestamp: number
  repoPath: number
  categoryScoresJson: number
  resultsJson: number
  productionReady: number
  readinessReasonsJson: number
  _all: number
}


export type RepoScanAvgAggregateInputType = {
  score?: true
}

export type RepoScanSumAggregateInputType = {
  score?: true
}

export type RepoScanMinAggregateInputType = {
  id?: true
  projectId?: true
  score?: true
  timestamp?: true
  repoPath?: true
  categoryScoresJson?: true
  resultsJson?: true
  productionReady?: true
  readinessReasonsJson?: true
}

export type RepoScanMaxAggregateInputType = {
  id?: true
  projectId?: true
  score?: true
  timestamp?: true
  repoPath?: true
  categoryScoresJson?: true
  resultsJson?: true
  productionReady?: true
  readinessReasonsJson?: true
}

export type RepoScanCountAggregateInputType = {
  id?: true
  projectId?: true
  score?: true
  timestamp?: true
  repoPath?: true
  categoryScoresJson?: true
  resultsJson?: true
  productionReady?: true
  readinessReasonsJson?: true
  _all?: true
}

export type RepoScanAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RepoScan to aggregate.
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RepoScans to fetch.
   */
  orderBy?: Prisma.RepoScanOrderByWithRelationInput | Prisma.RepoScanOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RepoScanWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RepoScans from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RepoScans.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned RepoScans
  **/
  _count?: true | RepoScanCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RepoScanAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RepoScanSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RepoScanMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RepoScanMaxAggregateInputType
}

export type GetRepoScanAggregateType<T extends RepoScanAggregateArgs> = {
      [P in keyof T & keyof AggregateRepoScan]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRepoScan[P]>
    : Prisma.GetScalarType<T[P], AggregateRepoScan[P]>
}




export type RepoScanGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RepoScanWhereInput
  orderBy?: Prisma.RepoScanOrderByWithAggregationInput | Prisma.RepoScanOrderByWithAggregationInput[]
  by: Prisma.RepoScanScalarFieldEnum[] | Prisma.RepoScanScalarFieldEnum
  having?: Prisma.RepoScanScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RepoScanCountAggregateInputType | true
  _avg?: RepoScanAvgAggregateInputType
  _sum?: RepoScanSumAggregateInputType
  _min?: RepoScanMinAggregateInputType
  _max?: RepoScanMaxAggregateInputType
}

export type RepoScanGroupByOutputType = {
  id: string
  projectId: string | null
  score: number
  timestamp: Date
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady: boolean | null
  readinessReasonsJson: string | null
  _count: RepoScanCountAggregateOutputType | null
  _avg: RepoScanAvgAggregateOutputType | null
  _sum: RepoScanSumAggregateOutputType | null
  _min: RepoScanMinAggregateOutputType | null
  _max: RepoScanMaxAggregateOutputType | null
}

type GetRepoScanGroupByPayload<T extends RepoScanGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RepoScanGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RepoScanGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RepoScanGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RepoScanGroupByOutputType[P]>
      }
    >
  >



export type RepoScanWhereInput = {
  AND?: Prisma.RepoScanWhereInput | Prisma.RepoScanWhereInput[]
  OR?: Prisma.RepoScanWhereInput[]
  NOT?: Prisma.RepoScanWhereInput | Prisma.RepoScanWhereInput[]
  id?: Prisma.StringFilter<"RepoScan"> | string
  projectId?: Prisma.StringNullableFilter<"RepoScan"> | string | null
  score?: Prisma.IntFilter<"RepoScan"> | number
  timestamp?: Prisma.DateTimeFilter<"RepoScan"> | Date | string
  repoPath?: Prisma.StringFilter<"RepoScan"> | string
  categoryScoresJson?: Prisma.StringFilter<"RepoScan"> | string
  resultsJson?: Prisma.StringFilter<"RepoScan"> | string
  productionReady?: Prisma.BoolNullableFilter<"RepoScan"> | boolean | null
  readinessReasonsJson?: Prisma.StringNullableFilter<"RepoScan"> | string | null
  project?: Prisma.XOR<Prisma.ProjectNullableScalarRelationFilter, Prisma.ProjectWhereInput> | null
}

export type RepoScanOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrderInput | Prisma.SortOrder
  score?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  repoPath?: Prisma.SortOrder
  categoryScoresJson?: Prisma.SortOrder
  resultsJson?: Prisma.SortOrder
  productionReady?: Prisma.SortOrderInput | Prisma.SortOrder
  readinessReasonsJson?: Prisma.SortOrderInput | Prisma.SortOrder
  project?: Prisma.ProjectOrderByWithRelationInput
}

export type RepoScanWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.RepoScanWhereInput | Prisma.RepoScanWhereInput[]
  OR?: Prisma.RepoScanWhereInput[]
  NOT?: Prisma.RepoScanWhereInput | Prisma.RepoScanWhereInput[]
  projectId?: Prisma.StringNullableFilter<"RepoScan"> | string | null
  score?: Prisma.IntFilter<"RepoScan"> | number
  timestamp?: Prisma.DateTimeFilter<"RepoScan"> | Date | string
  repoPath?: Prisma.StringFilter<"RepoScan"> | string
  categoryScoresJson?: Prisma.StringFilter<"RepoScan"> | string
  resultsJson?: Prisma.StringFilter<"RepoScan"> | string
  productionReady?: Prisma.BoolNullableFilter<"RepoScan"> | boolean | null
  readinessReasonsJson?: Prisma.StringNullableFilter<"RepoScan"> | string | null
  project?: Prisma.XOR<Prisma.ProjectNullableScalarRelationFilter, Prisma.ProjectWhereInput> | null
}, "id">

export type RepoScanOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrderInput | Prisma.SortOrder
  score?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  repoPath?: Prisma.SortOrder
  categoryScoresJson?: Prisma.SortOrder
  resultsJson?: Prisma.SortOrder
  productionReady?: Prisma.SortOrderInput | Prisma.SortOrder
  readinessReasonsJson?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.RepoScanCountOrderByAggregateInput
  _avg?: Prisma.RepoScanAvgOrderByAggregateInput
  _max?: Prisma.RepoScanMaxOrderByAggregateInput
  _min?: Prisma.RepoScanMinOrderByAggregateInput
  _sum?: Prisma.RepoScanSumOrderByAggregateInput
}

export type RepoScanScalarWhereWithAggregatesInput = {
  AND?: Prisma.RepoScanScalarWhereWithAggregatesInput | Prisma.RepoScanScalarWhereWithAggregatesInput[]
  OR?: Prisma.RepoScanScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RepoScanScalarWhereWithAggregatesInput | Prisma.RepoScanScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"RepoScan"> | string
  projectId?: Prisma.StringNullableWithAggregatesFilter<"RepoScan"> | string | null
  score?: Prisma.IntWithAggregatesFilter<"RepoScan"> | number
  timestamp?: Prisma.DateTimeWithAggregatesFilter<"RepoScan"> | Date | string
  repoPath?: Prisma.StringWithAggregatesFilter<"RepoScan"> | string
  categoryScoresJson?: Prisma.StringWithAggregatesFilter<"RepoScan"> | string
  resultsJson?: Prisma.StringWithAggregatesFilter<"RepoScan"> | string
  productionReady?: Prisma.BoolNullableWithAggregatesFilter<"RepoScan"> | boolean | null
  readinessReasonsJson?: Prisma.StringNullableWithAggregatesFilter<"RepoScan"> | string | null
}

export type RepoScanCreateInput = {
  id?: string
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
  project?: Prisma.ProjectCreateNestedOneWithoutScansInput
}

export type RepoScanUncheckedCreateInput = {
  id?: string
  projectId?: string | null
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
}

export type RepoScanUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  project?: Prisma.ProjectUpdateOneWithoutScansNestedInput
}

export type RepoScanUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type RepoScanCreateManyInput = {
  id?: string
  projectId?: string | null
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
}

export type RepoScanUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type RepoScanUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type RepoScanListRelationFilter = {
  every?: Prisma.RepoScanWhereInput
  some?: Prisma.RepoScanWhereInput
  none?: Prisma.RepoScanWhereInput
}

export type RepoScanOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RepoScanCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  score?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  repoPath?: Prisma.SortOrder
  categoryScoresJson?: Prisma.SortOrder
  resultsJson?: Prisma.SortOrder
  productionReady?: Prisma.SortOrder
  readinessReasonsJson?: Prisma.SortOrder
}

export type RepoScanAvgOrderByAggregateInput = {
  score?: Prisma.SortOrder
}

export type RepoScanMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  score?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  repoPath?: Prisma.SortOrder
  categoryScoresJson?: Prisma.SortOrder
  resultsJson?: Prisma.SortOrder
  productionReady?: Prisma.SortOrder
  readinessReasonsJson?: Prisma.SortOrder
}

export type RepoScanMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  score?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  repoPath?: Prisma.SortOrder
  categoryScoresJson?: Prisma.SortOrder
  resultsJson?: Prisma.SortOrder
  productionReady?: Prisma.SortOrder
  readinessReasonsJson?: Prisma.SortOrder
}

export type RepoScanSumOrderByAggregateInput = {
  score?: Prisma.SortOrder
}

export type RepoScanCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput> | Prisma.RepoScanCreateWithoutProjectInput[] | Prisma.RepoScanUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.RepoScanCreateOrConnectWithoutProjectInput | Prisma.RepoScanCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.RepoScanCreateManyProjectInputEnvelope
  connect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
}

export type RepoScanUncheckedCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput> | Prisma.RepoScanCreateWithoutProjectInput[] | Prisma.RepoScanUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.RepoScanCreateOrConnectWithoutProjectInput | Prisma.RepoScanCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.RepoScanCreateManyProjectInputEnvelope
  connect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
}

export type RepoScanUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput> | Prisma.RepoScanCreateWithoutProjectInput[] | Prisma.RepoScanUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.RepoScanCreateOrConnectWithoutProjectInput | Prisma.RepoScanCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.RepoScanUpsertWithWhereUniqueWithoutProjectInput | Prisma.RepoScanUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.RepoScanCreateManyProjectInputEnvelope
  set?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  disconnect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  delete?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  connect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  update?: Prisma.RepoScanUpdateWithWhereUniqueWithoutProjectInput | Prisma.RepoScanUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.RepoScanUpdateManyWithWhereWithoutProjectInput | Prisma.RepoScanUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.RepoScanScalarWhereInput | Prisma.RepoScanScalarWhereInput[]
}

export type RepoScanUncheckedUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput> | Prisma.RepoScanCreateWithoutProjectInput[] | Prisma.RepoScanUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.RepoScanCreateOrConnectWithoutProjectInput | Prisma.RepoScanCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.RepoScanUpsertWithWhereUniqueWithoutProjectInput | Prisma.RepoScanUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.RepoScanCreateManyProjectInputEnvelope
  set?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  disconnect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  delete?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  connect?: Prisma.RepoScanWhereUniqueInput | Prisma.RepoScanWhereUniqueInput[]
  update?: Prisma.RepoScanUpdateWithWhereUniqueWithoutProjectInput | Prisma.RepoScanUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.RepoScanUpdateManyWithWhereWithoutProjectInput | Prisma.RepoScanUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.RepoScanScalarWhereInput | Prisma.RepoScanScalarWhereInput[]
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type RepoScanCreateWithoutProjectInput = {
  id?: string
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
}

export type RepoScanUncheckedCreateWithoutProjectInput = {
  id?: string
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
}

export type RepoScanCreateOrConnectWithoutProjectInput = {
  where: Prisma.RepoScanWhereUniqueInput
  create: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput>
}

export type RepoScanCreateManyProjectInputEnvelope = {
  data: Prisma.RepoScanCreateManyProjectInput | Prisma.RepoScanCreateManyProjectInput[]
}

export type RepoScanUpsertWithWhereUniqueWithoutProjectInput = {
  where: Prisma.RepoScanWhereUniqueInput
  update: Prisma.XOR<Prisma.RepoScanUpdateWithoutProjectInput, Prisma.RepoScanUncheckedUpdateWithoutProjectInput>
  create: Prisma.XOR<Prisma.RepoScanCreateWithoutProjectInput, Prisma.RepoScanUncheckedCreateWithoutProjectInput>
}

export type RepoScanUpdateWithWhereUniqueWithoutProjectInput = {
  where: Prisma.RepoScanWhereUniqueInput
  data: Prisma.XOR<Prisma.RepoScanUpdateWithoutProjectInput, Prisma.RepoScanUncheckedUpdateWithoutProjectInput>
}

export type RepoScanUpdateManyWithWhereWithoutProjectInput = {
  where: Prisma.RepoScanScalarWhereInput
  data: Prisma.XOR<Prisma.RepoScanUpdateManyMutationInput, Prisma.RepoScanUncheckedUpdateManyWithoutProjectInput>
}

export type RepoScanScalarWhereInput = {
  AND?: Prisma.RepoScanScalarWhereInput | Prisma.RepoScanScalarWhereInput[]
  OR?: Prisma.RepoScanScalarWhereInput[]
  NOT?: Prisma.RepoScanScalarWhereInput | Prisma.RepoScanScalarWhereInput[]
  id?: Prisma.StringFilter<"RepoScan"> | string
  projectId?: Prisma.StringNullableFilter<"RepoScan"> | string | null
  score?: Prisma.IntFilter<"RepoScan"> | number
  timestamp?: Prisma.DateTimeFilter<"RepoScan"> | Date | string
  repoPath?: Prisma.StringFilter<"RepoScan"> | string
  categoryScoresJson?: Prisma.StringFilter<"RepoScan"> | string
  resultsJson?: Prisma.StringFilter<"RepoScan"> | string
  productionReady?: Prisma.BoolNullableFilter<"RepoScan"> | boolean | null
  readinessReasonsJson?: Prisma.StringNullableFilter<"RepoScan"> | string | null
}

export type RepoScanCreateManyProjectInput = {
  id?: string
  score: number
  timestamp?: Date | string
  repoPath: string
  categoryScoresJson: string
  resultsJson: string
  productionReady?: boolean | null
  readinessReasonsJson?: string | null
}

export type RepoScanUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type RepoScanUncheckedUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type RepoScanUncheckedUpdateManyWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  score?: Prisma.IntFieldUpdateOperationsInput | number
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  repoPath?: Prisma.StringFieldUpdateOperationsInput | string
  categoryScoresJson?: Prisma.StringFieldUpdateOperationsInput | string
  resultsJson?: Prisma.StringFieldUpdateOperationsInput | string
  productionReady?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  readinessReasonsJson?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}



export type RepoScanSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  score?: boolean
  timestamp?: boolean
  repoPath?: boolean
  categoryScoresJson?: boolean
  resultsJson?: boolean
  productionReady?: boolean
  readinessReasonsJson?: boolean
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}, ExtArgs["result"]["repoScan"]>

export type RepoScanSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  score?: boolean
  timestamp?: boolean
  repoPath?: boolean
  categoryScoresJson?: boolean
  resultsJson?: boolean
  productionReady?: boolean
  readinessReasonsJson?: boolean
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}, ExtArgs["result"]["repoScan"]>

export type RepoScanSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  score?: boolean
  timestamp?: boolean
  repoPath?: boolean
  categoryScoresJson?: boolean
  resultsJson?: boolean
  productionReady?: boolean
  readinessReasonsJson?: boolean
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}, ExtArgs["result"]["repoScan"]>

export type RepoScanSelectScalar = {
  id?: boolean
  projectId?: boolean
  score?: boolean
  timestamp?: boolean
  repoPath?: boolean
  categoryScoresJson?: boolean
  resultsJson?: boolean
  productionReady?: boolean
  readinessReasonsJson?: boolean
}

export type RepoScanOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "projectId" | "score" | "timestamp" | "repoPath" | "categoryScoresJson" | "resultsJson" | "productionReady" | "readinessReasonsJson", ExtArgs["result"]["repoScan"]>
export type RepoScanInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}
export type RepoScanIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}
export type RepoScanIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.RepoScan$projectArgs<ExtArgs>
}

export type $RepoScanPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "RepoScan"
  objects: {
    project: Prisma.$ProjectPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    projectId: string | null
    score: number
    timestamp: Date
    repoPath: string
    categoryScoresJson: string
    resultsJson: string
    productionReady: boolean | null
    readinessReasonsJson: string | null
  }, ExtArgs["result"]["repoScan"]>
  composites: {}
}

export type RepoScanGetPayload<S extends boolean | null | undefined | RepoScanDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RepoScanPayload, S>

export type RepoScanCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RepoScanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RepoScanCountAggregateInputType | true
  }

export interface RepoScanDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepoScan'], meta: { name: 'RepoScan' } }
  /**
   * Find zero or one RepoScan that matches the filter.
   * @param {RepoScanFindUniqueArgs} args - Arguments to find a RepoScan
   * @example
   * // Get one RepoScan
   * const repoScan = await prisma.repoScan.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RepoScanFindUniqueArgs>(args: Prisma.SelectSubset<T, RepoScanFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one RepoScan that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RepoScanFindUniqueOrThrowArgs} args - Arguments to find a RepoScan
   * @example
   * // Get one RepoScan
   * const repoScan = await prisma.repoScan.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RepoScanFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RepoScanFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RepoScan that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanFindFirstArgs} args - Arguments to find a RepoScan
   * @example
   * // Get one RepoScan
   * const repoScan = await prisma.repoScan.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RepoScanFindFirstArgs>(args?: Prisma.SelectSubset<T, RepoScanFindFirstArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RepoScan that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanFindFirstOrThrowArgs} args - Arguments to find a RepoScan
   * @example
   * // Get one RepoScan
   * const repoScan = await prisma.repoScan.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RepoScanFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RepoScanFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more RepoScans that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all RepoScans
   * const repoScans = await prisma.repoScan.findMany()
   * 
   * // Get first 10 RepoScans
   * const repoScans = await prisma.repoScan.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const repoScanWithIdOnly = await prisma.repoScan.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RepoScanFindManyArgs>(args?: Prisma.SelectSubset<T, RepoScanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a RepoScan.
   * @param {RepoScanCreateArgs} args - Arguments to create a RepoScan.
   * @example
   * // Create one RepoScan
   * const RepoScan = await prisma.repoScan.create({
   *   data: {
   *     // ... data to create a RepoScan
   *   }
   * })
   * 
   */
  create<T extends RepoScanCreateArgs>(args: Prisma.SelectSubset<T, RepoScanCreateArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many RepoScans.
   * @param {RepoScanCreateManyArgs} args - Arguments to create many RepoScans.
   * @example
   * // Create many RepoScans
   * const repoScan = await prisma.repoScan.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RepoScanCreateManyArgs>(args?: Prisma.SelectSubset<T, RepoScanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many RepoScans and returns the data saved in the database.
   * @param {RepoScanCreateManyAndReturnArgs} args - Arguments to create many RepoScans.
   * @example
   * // Create many RepoScans
   * const repoScan = await prisma.repoScan.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many RepoScans and only return the `id`
   * const repoScanWithIdOnly = await prisma.repoScan.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RepoScanCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RepoScanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a RepoScan.
   * @param {RepoScanDeleteArgs} args - Arguments to delete one RepoScan.
   * @example
   * // Delete one RepoScan
   * const RepoScan = await prisma.repoScan.delete({
   *   where: {
   *     // ... filter to delete one RepoScan
   *   }
   * })
   * 
   */
  delete<T extends RepoScanDeleteArgs>(args: Prisma.SelectSubset<T, RepoScanDeleteArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one RepoScan.
   * @param {RepoScanUpdateArgs} args - Arguments to update one RepoScan.
   * @example
   * // Update one RepoScan
   * const repoScan = await prisma.repoScan.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RepoScanUpdateArgs>(args: Prisma.SelectSubset<T, RepoScanUpdateArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more RepoScans.
   * @param {RepoScanDeleteManyArgs} args - Arguments to filter RepoScans to delete.
   * @example
   * // Delete a few RepoScans
   * const { count } = await prisma.repoScan.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RepoScanDeleteManyArgs>(args?: Prisma.SelectSubset<T, RepoScanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RepoScans.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many RepoScans
   * const repoScan = await prisma.repoScan.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RepoScanUpdateManyArgs>(args: Prisma.SelectSubset<T, RepoScanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RepoScans and returns the data updated in the database.
   * @param {RepoScanUpdateManyAndReturnArgs} args - Arguments to update many RepoScans.
   * @example
   * // Update many RepoScans
   * const repoScan = await prisma.repoScan.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more RepoScans and only return the `id`
   * const repoScanWithIdOnly = await prisma.repoScan.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RepoScanUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RepoScanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one RepoScan.
   * @param {RepoScanUpsertArgs} args - Arguments to update or create a RepoScan.
   * @example
   * // Update or create a RepoScan
   * const repoScan = await prisma.repoScan.upsert({
   *   create: {
   *     // ... data to create a RepoScan
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the RepoScan we want to update
   *   }
   * })
   */
  upsert<T extends RepoScanUpsertArgs>(args: Prisma.SelectSubset<T, RepoScanUpsertArgs<ExtArgs>>): Prisma.Prisma__RepoScanClient<runtime.Types.Result.GetResult<Prisma.$RepoScanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of RepoScans.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanCountArgs} args - Arguments to filter RepoScans to count.
   * @example
   * // Count the number of RepoScans
   * const count = await prisma.repoScan.count({
   *   where: {
   *     // ... the filter for the RepoScans we want to count
   *   }
   * })
  **/
  count<T extends RepoScanCountArgs>(
    args?: Prisma.Subset<T, RepoScanCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RepoScanCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a RepoScan.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RepoScanAggregateArgs>(args: Prisma.Subset<T, RepoScanAggregateArgs>): Prisma.PrismaPromise<GetRepoScanAggregateType<T>>

  /**
   * Group by RepoScan.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RepoScanGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RepoScanGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RepoScanGroupByArgs['orderBy'] }
      : { orderBy?: RepoScanGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RepoScanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepoScanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the RepoScan model
 */
readonly fields: RepoScanFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for RepoScan.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RepoScanClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  project<T extends Prisma.RepoScan$projectArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.RepoScan$projectArgs<ExtArgs>>): Prisma.Prisma__ProjectClient<runtime.Types.Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the RepoScan model
 */
export interface RepoScanFieldRefs {
  readonly id: Prisma.FieldRef<"RepoScan", 'String'>
  readonly projectId: Prisma.FieldRef<"RepoScan", 'String'>
  readonly score: Prisma.FieldRef<"RepoScan", 'Int'>
  readonly timestamp: Prisma.FieldRef<"RepoScan", 'DateTime'>
  readonly repoPath: Prisma.FieldRef<"RepoScan", 'String'>
  readonly categoryScoresJson: Prisma.FieldRef<"RepoScan", 'String'>
  readonly resultsJson: Prisma.FieldRef<"RepoScan", 'String'>
  readonly productionReady: Prisma.FieldRef<"RepoScan", 'Boolean'>
  readonly readinessReasonsJson: Prisma.FieldRef<"RepoScan", 'String'>
}
    

// Custom InputTypes
/**
 * RepoScan findUnique
 */
export type RepoScanFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter, which RepoScan to fetch.
   */
  where: Prisma.RepoScanWhereUniqueInput
}

/**
 * RepoScan findUniqueOrThrow
 */
export type RepoScanFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter, which RepoScan to fetch.
   */
  where: Prisma.RepoScanWhereUniqueInput
}

/**
 * RepoScan findFirst
 */
export type RepoScanFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter, which RepoScan to fetch.
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RepoScans to fetch.
   */
  orderBy?: Prisma.RepoScanOrderByWithRelationInput | Prisma.RepoScanOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RepoScans.
   */
  cursor?: Prisma.RepoScanWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RepoScans from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RepoScans.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RepoScans.
   */
  distinct?: Prisma.RepoScanScalarFieldEnum | Prisma.RepoScanScalarFieldEnum[]
}

/**
 * RepoScan findFirstOrThrow
 */
export type RepoScanFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter, which RepoScan to fetch.
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RepoScans to fetch.
   */
  orderBy?: Prisma.RepoScanOrderByWithRelationInput | Prisma.RepoScanOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RepoScans.
   */
  cursor?: Prisma.RepoScanWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RepoScans from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RepoScans.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RepoScans.
   */
  distinct?: Prisma.RepoScanScalarFieldEnum | Prisma.RepoScanScalarFieldEnum[]
}

/**
 * RepoScan findMany
 */
export type RepoScanFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter, which RepoScans to fetch.
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RepoScans to fetch.
   */
  orderBy?: Prisma.RepoScanOrderByWithRelationInput | Prisma.RepoScanOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing RepoScans.
   */
  cursor?: Prisma.RepoScanWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RepoScans from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RepoScans.
   */
  skip?: number
  distinct?: Prisma.RepoScanScalarFieldEnum | Prisma.RepoScanScalarFieldEnum[]
}

/**
 * RepoScan create
 */
export type RepoScanCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * The data needed to create a RepoScan.
   */
  data: Prisma.XOR<Prisma.RepoScanCreateInput, Prisma.RepoScanUncheckedCreateInput>
}

/**
 * RepoScan createMany
 */
export type RepoScanCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many RepoScans.
   */
  data: Prisma.RepoScanCreateManyInput | Prisma.RepoScanCreateManyInput[]
}

/**
 * RepoScan createManyAndReturn
 */
export type RepoScanCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * The data used to create many RepoScans.
   */
  data: Prisma.RepoScanCreateManyInput | Prisma.RepoScanCreateManyInput[]
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * RepoScan update
 */
export type RepoScanUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * The data needed to update a RepoScan.
   */
  data: Prisma.XOR<Prisma.RepoScanUpdateInput, Prisma.RepoScanUncheckedUpdateInput>
  /**
   * Choose, which RepoScan to update.
   */
  where: Prisma.RepoScanWhereUniqueInput
}

/**
 * RepoScan updateMany
 */
export type RepoScanUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update RepoScans.
   */
  data: Prisma.XOR<Prisma.RepoScanUpdateManyMutationInput, Prisma.RepoScanUncheckedUpdateManyInput>
  /**
   * Filter which RepoScans to update
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * Limit how many RepoScans to update.
   */
  limit?: number
}

/**
 * RepoScan updateManyAndReturn
 */
export type RepoScanUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * The data used to update RepoScans.
   */
  data: Prisma.XOR<Prisma.RepoScanUpdateManyMutationInput, Prisma.RepoScanUncheckedUpdateManyInput>
  /**
   * Filter which RepoScans to update
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * Limit how many RepoScans to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * RepoScan upsert
 */
export type RepoScanUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * The filter to search for the RepoScan to update in case it exists.
   */
  where: Prisma.RepoScanWhereUniqueInput
  /**
   * In case the RepoScan found by the `where` argument doesn't exist, create a new RepoScan with this data.
   */
  create: Prisma.XOR<Prisma.RepoScanCreateInput, Prisma.RepoScanUncheckedCreateInput>
  /**
   * In case the RepoScan was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RepoScanUpdateInput, Prisma.RepoScanUncheckedUpdateInput>
}

/**
 * RepoScan delete
 */
export type RepoScanDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
  /**
   * Filter which RepoScan to delete.
   */
  where: Prisma.RepoScanWhereUniqueInput
}

/**
 * RepoScan deleteMany
 */
export type RepoScanDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RepoScans to delete
   */
  where?: Prisma.RepoScanWhereInput
  /**
   * Limit how many RepoScans to delete.
   */
  limit?: number
}

/**
 * RepoScan.project
 */
export type RepoScan$projectArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Project
   */
  select?: Prisma.ProjectSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Project
   */
  omit?: Prisma.ProjectOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectInclude<ExtArgs> | null
  where?: Prisma.ProjectWhereInput
}

/**
 * RepoScan without action
 */
export type RepoScanDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RepoScan
   */
  select?: Prisma.RepoScanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RepoScan
   */
  omit?: Prisma.RepoScanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RepoScanInclude<ExtArgs> | null
}
